# Process followed during the project
This document describes the process we followed and the elements we tested to make the JSON parser and the visual report.

## JSON Parser
We quickly decided to manually parse the JSON, as existing libraries were not up to our expectation. The parsing now creates a dictionnary based on the given JSON.

We've then analyzed the structure of the different traces generated by Openstack and identified different types of what we call **components** mapped to the components from Openstack :
  - **db** and **neutron.db** are considered **DBComponent**
  - **compute_api**, **neutron_api**, **nova_image**, **rpc**, **l3-agent**, **vif_driver** are considered **FunctionComponent**
  - **wsgi** is considered **HttpComponent**

*NB: please look at the Implementation section in the [README](README.md) to learn more about these components*

*NB2: in case you need to add a new Openstack component for it to be parsed, just add it to the type array property of the concerned component object*

## SQL Parser
Our initial idea was to use a SQLParser generated with Antlr4 in order to get as much information as possible. However, while this solution worked well, the execution was far too long. The [SQLParser](https://github.com/Openstack-SQL/SQLParser) project still remains in the solution, as it may be necessary in further developments requiring more information.

On second thought, we simplified SQLParser a lot, and reduced it to a word counter on the SQL statements. While it gets less information, it is about 150 times faster than an SQLParser.

It is possible to switch between the two solutions by commenting / decommenting one line in the JSONParser.

## Visual report
The goal of this visual report is to show the main metrics of each request to see where can be found huge time consumption.
1. First, we tried to use [Graphviz](https://www.graphviz.org/) to make a tree view of the request calls and to see the parent/children relationship between the requests.
After generating a few graphs, we abandonned it because of the illegibility of the generated tree, which was too small on the page, 
and requested a huge zoom in to see something. Moreover, the tree wasn't disposed in a helpful way.
2. Then, we tried [Grafana](https://grafana.com/), which is already used to monitor some metrics in OpenStack. But it was too powerfull for what we were trying to do, 
and we lost some time to try to use it for the metrics form our generated JSON.
3. Finally, we choose to use [Plotly](https://plot.ly/python/), in order to generate a webpage which contains all our graphs. It simply generates an HTML page from a python source code.
